use std::{
    collections::{HashMap, HashSet},
    ops::RangeBounds,
    time::Instant,
};

use itertools::Itertools;
use rayon::iter::{ParallelBridge, ParallelIterator};

const INPUT: &str = "
7,1
11,1
11,7
9,7
9,5
2,5
2,3
7,3
";

const INPUT2: &str = "
97998,50303
97998,51528
98246,51528
98246,52758
98334,52758
98334,53970
98115,53970
98115,55177
97898,55177
97898,56309
97159,56309
97159,57617
97707,57617
97707,58713
96904,58713
96904,60057
97417,60057
97417,61182
96839,61182
96839,62334
96426,62334
96426,63382
95674,63382
95674,64674
95755,64674
95755,65711
95031,65711
95031,66823
94555,66823
94555,68115
94529,68115
94529,69185
93936,69185
93936,70384
93635,70384
93635,71488
93115,71488
93115,72421
92270,72421
92270,73762
92180,73762
92180,74512
91044,74512
91044,75481
90310,75481
90310,76703
89964,76703
89964,77769
89363,77769
89363,78593
88427,78593
88427,79337
87409,79337
87409,80427
86837,80427
86837,81183
85862,81183
85862,82445
85458,82445
85458,83477
84774,83477
84774,83852
83426,83852
83426,85235
83071,85235
83071,85537
81700,85537
81700,86426
80873,86426
80873,87469
80159,87469
80159,88137
79136,88137
79136,88518
77911,88518
77911,89959
77438,89959
77438,90457
76297,90457
76297,90971
75179,90971
75179,91761
74229,91761
74229,91746
72826,91746
72826,92265
71738,92265
71738,93465
70980,93465
70980,93661
69727,93661
69727,94316
68686,94316
68686,94272
67360,94272
67360,95291
66448,95291
66448,95059
65084,95059
65084,95590
63987,95590
63987,96434
62969,96434
62969,96662
61767,96662
61767,96847
60559,96847
60559,97053
59359,97053
59359,97523
58207,97523
58207,97650
56991,97650
56991,98054
55811,98054
55811,97451
54522,97451
54522,97689
53328,97689
53328,97953
52127,97953
52127,97864
50909,97864
50909,98366
49693,98366
49693,98315
48469,98315
48469,98159
47251,98159
47251,98205
46021,98205
46021,97848
44828,97848
44828,97108
43697,97108
43697,97425
42427,97425
42427,97503
41175,97503
41175,97191
39990,97191
39990,97070
38762,97070
38762,96288
37701,96288
37701,96076
36499,96076
36499,95419
35433,95419
35433,94861
34348,94861
34348,94784
33090,94784
33090,94829
31763,94829
31763,94258
30674,94258
30674,93373
29737,93373
29737,93143
28497,93143
28497,92022
27709,92022
27709,91485
26629,91485
26629,90985
25522,90985
25522,90741
24246,90741
24246,89612
23531,89612
23531,89523
22117,89523
22117,88385
21437,88385
21437,87405
20665,87405
20665,87238
19241,87238
19241,86130
18583,86130
18583,85088
17893,85088
17893,84703
16590,84703
16590,83825
15743,83825
15743,82803
15050,82803
15050,81866
14276,81866
14276,81072
13337,81072
13337,80391
12242,80391
12242,79021
12013,79021
12013,77975
11391,77975
11391,77057
10595,77057
10595,76021
9968,76021
9968,75243
8923,75243
8923,74335
8054,74335
8054,72866
8181,72866
8181,72143
6946,72143
6946,70926
6645,70926
6645,69726
6341,69726
6341,68686
5682,68686
5682,67631
5036,67631
5036,66267
5207,66267
5207,65274
4370,65274
4370,64168
3821,64168
3821,62871
3916,62871
3916,61699
3607,61699
3607,60501
3410,60501
3410,59354
2974,59354
2974,58111
3033,58111
3033,57017
2171,57017
2171,55746
2482,55746
2482,54506
2707,54506
2707,53326
2329,53326
2329,52129
2016,52129
2016,50915
1827,50915
1827,50282
94634,50282
94634,48476
1893,48476
1893,47248
1776,47248
1776,46074
2434,46074
2434,44799
1884,44799
1884,43693
2865,43693
2865,42392
2359,42392
2359,41261
2960,41261
2960,40106
3355,40106
3355,38768
2955,38768
2955,37763
3943,37763
3943,36629
4364,36629
4364,35477
4719,35477
4719,34111
4459,34111
4459,33136
5337,33136
5337,31745
5128,31745
5128,30754
5924,30754
5924,29638
6413,29638
6413,28546
6954,28546
6954,27378
7353,27378
7353,26318
7962,26318
7962,25564
9084,25564
9084,24417
9529,24417
9529,23328
10083,23328
10083,22425
10913,22425
10913,21310
11444,21310
11444,20183
11980,20183
11980,19325
12863,19325
12863,18695
13998,18695
13998,17477
14457,17477
14457,16502
15204,16502
15204,15904
16333,15904
16333,14770
16934,14770
16934,14552
18379,14552
18379,13090
18717,13090
18717,12644
19932,12644
19932,12082
21031,12082
21031,11389
22022,11389
22022,10759
23054,10759
23054,9736
23827,9736
23827,8768
24660,8768
24660,8625
25995,8625
25995,7687
26863,7687
26863,7039
27904,7039
27904,6956
29222,6956
29222,5871
30061,5871
30061,5332
31165,5332
31165,5706
32631,5706
32631,4818
33590,4818
33590,4945
34917,4945
34917,4278
35972,4278
35972,3836
37106,3836
37106,3749
38336,3749
38336,2863
39375,2863
39375,2609
40573,2609
40573,3106
41901,3106
41901,2312
43003,2312
43003,2822
44294,2822
44294,1975
45423,1975
45423,2483
46683,2483
46683,1823
47862,1823
47862,2243
49092,2243
49092,2139
50302,2139
50302,1905
51523,1905
51523,1910
52744,1910
52744,2343
53932,2343
53932,2095
55177,2095
55177,2186
56397,2186
56397,2127
57644,2127
57644,2494
58825,2494
58825,3039
59960,3039
59960,3510
61098,3510
61098,3844
62262,3844
62262,4388
63364,4388
63364,4564
64572,4564
64572,4253
65960,4253
65960,5532
66789,5532
66789,5319
68176,5319
68176,6465
69009,6465
69009,6247
70439,6247
70439,7042
71410,7042
71410,7535
72524,7535
72524,8119
73593,8119
73593,9007
74481,9007
74481,9538
75577,9538
75577,9905
76789,9905
76789,11116
77430,11116
77430,11583
78585,11583
78585,11849
79918,11849
79918,13153
80435,13153
80435,13612
81640,13612
81640,14269
82694,14269
82694,15279
83425,15279
83425,15941
84492,15941
84492,17225
84918,17225
84918,17841
86050,17841
86050,18712
86916,18712
86916,19789
87532,19789
87532,20819
88194,20819
88194,21664
89103,21664
89103,22895
89472,22895
89472,24102
89841,24102
89841,24678
91203,24678
91203,25946
91459,25946
91459,27209
91680,27209
91680,27992
92788,27992
92788,29310
92862,29310
92862,30245
93722,30245
93722,31424
94054,31424
94054,32431
94802,32431
94802,33678
94940,33678
94940,34758
95529,34758
95529,36041
95496,36041
95496,37029
96437,37029
96437,38171
96904,38171
96904,39411
96978,39411
96978,40549
97510,40549
97510,41824
97339,41824
97339,43036
97462,43036
97462,44212
97854,44212
97854,45458
97650,45458
97650,46670
97712,46670
97712,47869
98012,47869
98012,49094
97638,49094
97638,50303
";

const INPUT3: &str = "
97994,50070
97994,51278
97682,51278
97682,52505
97995,52505
97995,53745
98244,53745
98244,54964
98109,54964
98109,56103
97365,56103
97365,57313
97276,57313
97276,58596
97556,58596
97556,59830
97479,59830
97479,60989
97039,60989
97039,62039
96217,62039
96217,63145
95686,63145
95686,64448
95814,64448
95814,65748
95853,65748
95853,66647
94747,66647
94747,67740
94221,67740
94221,69177
94508,69177
94508,69966
93286,69966
93286,71118
92891,71118
92891,72251
92444,72251
92444,73132
91532,73132
91532,74291
91126,74291
91126,75674
91054,75674
91054,76263
89722,76263
89722,77520
89415,77520
89415,78190
88271,78190
88271,79203
87612,79203
87612,80165
86883,80165
86883,81041
86051,81041
86051,82014
85329,82014
85329,83391
85024,83391
85024,83904
83804,83904
83804,84522
82719,84522
82719,85478
81958,85478
81958,86562
81294,86562
81294,86931
80022,86931
80022,88355
79598,88355
79598,88998
78548,88998
78548,89076
77112,89076
77112,89777
76131,89777
76131,91003
75473,91003
75473,91653
74437,91653
74437,91715
73073,91715
73073,92720
72235,92720
72235,93032
71029,93032
71029,93510
69913,93510
69913,93849
68740,93849
68740,94361
67644,94361
67644,94984
66584,94984
66584,95653
65529,95653
65529,96098
64388,96098
64388,96560
63248,96560
63248,96428
61948,96428
61948,96495
60717,96495
60717,96844
59554,96844
59554,97070
58364,97070
58364,97854
57258,97854
57258,98024
56044,98024
56044,98135
54823,98135
54823,97727
53563,97727
53563,97475
52337,97475
52337,97900
51143,97900
51143,97724
49929,97724
49929,98019
48712,98019
48712,98154
47486,98154
47486,98236
46254,98236
46254,98092
45037,98092
45037,97874
43830,97874
43830,97381
42669,97381
42669,97498
41414,97498
41414,97371
40191,97371
40191,96505
39135,96505
39135,96596
37861,96596
37861,96307
36675,96307
36675,96011
35489,96011
35489,95113
34505,95113
34505,94957
33274,94957
33274,94735
32053,94735
32053,94046
31020,94046
31020,93731
29828,93731
29828,93348
28657,93348
28657,92289
27829,92289
27829,91861
26684,91861
26684,91469
25505,91469
25505,90441
24709,90441
24709,90456
23251,90456
23251,89722
22264,89722
22264,88735
21468,88735
21468,87709
20721,87709
20721,87366
19439,87366
19439,86196
18833,86196
18833,85478
17850,85478
17850,85024
16607,85024
16607,83796
16103,83796
16103,83109
15065,83109
15065,82305
14136,82305
14136,81022
13755,81022
13755,80387
12620,80387
12620,79261
12081,79261
12081,78324
11307,78324
11307,77449
10437,77449
10437,76125
10231,76125
10231,75270
9324,75270
9324,74200
8749,74200
8749,73000
8417,73000
8417,72212
7323,72212
7323,70999
7029,70999
7029,69923
6468,69923
6468,69035
5460,69035
5460,67816
5205,67816
5205,66499
5246,66499
5246,65319
4964,65319
4964,64209
4474,64209
4474,63212
3565,63212
3565,61927
3651,61927
3651,60738
3411,60738
3411,59645
2710,59645
2710,58413
2657,58413
2657,57226
2355,57226
2355,55990
2399,55990
2399,54814
1949,54814
1949,53595
1849,53595
1849,52341
2448,52341
2448,51146
1944,51146
1944,50065
94598,50065
94598,48717
2169,48717
2169,47489
1906,47489
1906,46273
1996,46273
1996,45076
2283,45076
2283,43838
2187,43838
2187,42737
3057,42737
3057,41440
2645,41440
2645,40280
3055,40280
3055,39120
3429,39120
3429,37828
3274,37828
3274,36754
3965,36754
3965,35579
4275,35579
4275,34377
4513,34377
4513,33327
5185,33327
5185,32309
5900,32309
5900,31151
6256,31151
6256,29783
6170,29783
6170,28753
6846,28753
6846,27522
7122,27522
7122,26666
8107,26666
8107,25368
8297,25368
8297,24548
9301,24548
9301,23431
9815,23431
9815,22558
10697,22558
10697,21334
11083,21334
11083,20740
12314,20740
12314,19686
12935,19686
12935,18704
13654,18704
13654,17977
14661,17977
14661,16842
15221,16842
15221,15856
15957,15856
15957,15485
17288,15485
17288,14164
17720,14164
17720,13794
19011,13794
19011,12618
19611,12618
19611,11630
20390,11630
20390,11270
21648,11270
21648,10386
22514,10386
22514,9894
23652,9894
23652,9053
24561,9053
24561,8745
25796,8745
25796,8325
26949,8325
26949,7285
27767,7285
27767,7219
29093,7219
29093,6721
30191,6721
30191,5999
31194,5999
31194,5092
32138,5092
32138,5165
33470,5165
33470,4821
34632,4821
34632,4323
35742,4323
35742,4226
36975,4226
36975,3808
38112,3808
38112,3519
39286,3519
39286,3211
40456,3211
40456,2462
41552,2462
41552,2979
42867,2979
42867,2613
44035,2613
44035,1875
45178,1875
45178,2010
46416,2010
46416,2152
47644,2152
47644,2087
48856,2087
48856,2499
50070,2499
50070,2291
51279,2291
51279,1773
52517,1773
52517,2521
53686,2521
53686,2466
54904,2466
54904,2421
56130,2421
56130,2980
57274,2980
57274,3195
58460,3195
58460,2978
59735,2978
59735,3035
60971,3035
60971,3947
61996,3947
61996,3800
63293,3800
63293,3990
64510,3990
64510,4924
65481,4924
65481,5179
66674,5179
66674,5726
67760,5726
67760,5941
68983,5941
68983,6523
70053,6523
70053,6737
71300,6737
71300,7305
72382,7305
72382,7710
73554,7710
73554,8877
74289,8877
74289,9362
75412,9362
75412,10309
76242,10309
76242,10551
77543,10551
77543,11204
78576,11204
78576,12164
79376,12164
79376,12717
80491,12717
80491,13412
81503,13412
81503,14593
82084,14593
82084,15145
83229,15145
83229,15950
84150,15950
84150,17034
84782,17034
84782,17694
85863,17694
85863,18932
86297,18932
86297,19445
87585,19445
87585,20914
87690,20914
87690,21842
88464,21842
88464,22561
89546,22561
89546,23717
90007,23717
90007,24543
90975,24543
90975,25513
91737,25513
91737,26805
91934,26805
91934,27736
92775,27736
92775,28815
93348,28815
93348,30007
93680,30007
93680,31263
93839,31263
93839,32086
95037,32086
95037,33557
94598,33557
94598,34686
95017,34686
95017,35644
95992,35644
95992,36904
96023,36904
96023,38064
96379,38064
96379,39183
96924,39183
96924,40440
96868,40440
96868,41593
97302,41593
97302,42850
97132,42850
97132,43965
97949,43965
97949,45203
97868,45203
97868,46434
97749,46434
97749,47650
97724,47650
97724,48856
97917,48856
97917,50070
";

pub fn run() {
    let now = Instant::now();
    part1();
    let elapsed = now.elapsed();
    println!(
        "Part1 Elapsed: {}μs, {}ms",
        elapsed.as_micros(),
        elapsed.as_millis()
    );

    let now = Instant::now();
    part2();
    let elapsed = now.elapsed();
    println!(
        "Part2 Elapsed: {}μs, {}ms",
        elapsed.as_micros(),
        elapsed.as_millis()
    );
}

fn part1() {
    // Filter out so its only the points that are min/max on at least one dimension
    let points: Vec<(isize, isize)> = INPUT2
        .lines()
        .filter_map(|l| l.split_once(','))
        .map(|(l, r)| (l.parse().unwrap(), r.parse().unwrap()))
        .collect_vec();

    let area = points
        .clone()
        .iter()
        .cartesian_product(points)
        .map(|(p1, p2)| (p2.0 - p1.0 + 1).abs() * (p2.1 - p1.1 + 1).abs())
        .max()
        .unwrap();

    println!("{}", area);
}

struct Ray {
    p1: (isize, isize),
    p2: (isize, isize),
    done: bool,
}

impl Ray {
    fn new(p1: (isize, isize), p2: (isize, isize)) -> Self {
        Ray {
            p1,
            p2,
            done: false,
        }
    }
}

impl Iterator for Ray {
    type Item = (isize, isize);

    fn next(&mut self) -> Option<Self::Item> {
        if self.done {
            return None;
        }

        let out = self.p1;

        if self.p1 == self.p2 {
            self.done = true;
            return Some(out);
        }

        if self.p1.1 < self.p2.1 {
            self.p1.1 += 1;
        } else if self.p1.1 > self.p2.1 {
            self.p1.1 -= 1;
        }
        if self.p1.0 < self.p2.0 {
            self.p1.0 += 1;
        } else if self.p1.0 > self.p2.0 {
            self.p1.0 -= 1;
        }

        Some(out)
    }
}

fn part2() {
    // Filter out so its only the points that are min/max on at least one dimension
    let points: Vec<(isize, isize)> = INPUT2
        .lines()
        .filter_map(|l| l.split_once(','))
        .map(|(l, r)| (l.parse().unwrap(), r.parse().unwrap()))
        .collect_vec();

    let mut xc = 1;
    let mut yc = 1;
    let mut xm = HashMap::new();
    let mut xmi = HashMap::new();
    let mut ym = HashMap::new();
    let mut ymi = HashMap::new();

    for x in points.iter().map(|p| p.0).sorted() {
        if !xm.contains_key(&x) {
            xm.insert(x, xc);
            xmi.insert(xc, x);
            xc += 1;
        }
    }
    for y in points.iter().map(|p| p.1).sorted() {
        if !ym.contains_key(&y) {
            ym.insert(y, yc);
            ymi.insert(yc, y);
            yc += 1;
        }
    }

    let points = points
        .into_iter()
        .map(|(x, y)| (xm[&x], ym[&y]))
        .collect_vec();
    let edge_points = points
        .iter()
        .circular_tuple_windows()
        .flat_map(|(t1, t2)| Ray::new(*t1, *t2).into_iter())
        .collect_vec();
    // let points = edge_points.clone();

    // Initialize the grid with 1s on the edges
    let mut grid = vec![vec![0; xc as usize + 1]; yc as usize + 1];
    for (x, y) in edge_points {
        grid[y as usize][x as usize] = 1;
    }

    // Floodfill the outside with 2s
    let mut frontier = vec![(0, 0)];
    let mut seen = HashSet::new();
    seen.insert((0, 0));
    while let Some((x, y)) = frontier.pop() {
        if grid[y as usize][x as usize] == 1 {
            continue;
        } else {
            grid[y as usize][x as usize] = 2;
        }

        for dx in -1isize..=1 {
            for dy in -1isize..=1 {
                if 0 <= x + dx
                    && x + dx < grid[0].len() as isize
                    && 0 <= y + dy
                    && y + dy < grid.len() as isize
                    && !seen.contains(&(x + dx, y + dy))
                {
                    seen.insert((x + dx, y + dy));
                    frontier.push((x + dx, y + dy));
                }
            }
        }
    }

    let binding = points.clone();
    let pairs = binding.iter().cartesian_product(points);
    let mut areas = pairs
        .map(|(p1, p2)| {
            (
                ((xmi[&p2.0] - xmi[&p1.0]).abs() + 1) * ((ymi[&p2.1] - ymi[&p1.1]).abs() + 1),
                p1,
                p2,
            )
        })
        .par_bridge()
        .filter(|(_, p1, p2)| {
            let lb = (p1.0.min(p2.0), p1.1.min(p2.1));
            let ub = (p1.0.max(p2.0), p1.1.max(p2.1));
            for y in lb.1..=ub.1 {
                for x in lb.0..=ub.0 {
                    if grid[y as usize][x as usize] == 2 {
                        return false;
                    }
                }
            }
            true
        })
        .collect::<Vec<_>>();

    areas.sort();
    areas.reverse();

    let (area, p1, p2) = areas[0];
    // let p1 = (xm[&5246], ym[&66499]);
    // let p2 = (xm[&94598], ym[&50065]);
    // dbg!(xmi[&p1.0], xmi[&p2.0], ymi[&p1.1], ymi[&p2.1]);
    // let area = (xmi[&p2.0] - xmi[&p1.0] + 1).abs() * (ymi[&p2.1] - ymi[&p1.1] + 1).abs();
    // dbg!(area);
    // panic!();

    let lb = (p1.0.min(p2.0), p1.1.min(p2.1));
    let ub = (p1.0.max(p2.0), p1.1.max(p2.1));
    for y in lb.1..=ub.1 {
        for x in lb.0..=ub.0 {
            grid[y as usize][x as usize] += 3;
        }
    }

    for row in &grid {
        for c in row {
            let colored = match c {
                2 => format!("\x1b[31m{}\x1b[0m", c),
                1 => format!("\x1b[33m{}\x1b[0m", c),
                0 => format!("\x1b[37m{}\x1b[0m", c),
                _ => format!("\x1b[32m{}\x1b[0m", c),
            };
            print!("{}", colored);
        }
        println!("");
    }

    println!("{}", area);
}
